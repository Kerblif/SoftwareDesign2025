# Отчет о контрольной работе №1 "Паттерны проектирования"

## 1. Общая идея решения

Разработанное консольное приложение "HSE Finance" предназначено для учета личных финансов. Приложение предоставляет пользователю возможность управлять своими финансами через взаимодействие с тремя основными сущностями: банковскими счетами, категориями доходов/расходов и операциями (транзакциями).

**Основные реализованные функциональности:**

*   **Управление банковскими счетами:**
    *   Создание нового банковского счета с указанием названия.
    *   Просмотр списка всех созданных счетов с их идентификаторами, названиями и текущим балансом.
    *   Удаление банковского счета.
    *   Редактирование названия и баланса существующего счета.
    *   Функция пересчета баланса счета на основе всех связанных операций.
    *   Импорт и экспорт данных о счетах в форматах JSON и CSV.

*   **Управление категориями:**
    *   Создание новых категорий с указанием типа (доход или расход) и названия.
    *   Просмотр списка всех категорий с их идентификаторами, типами и названиями.
    *   Удаление категорий.
    *   Редактирование названия и типа категории.
    *   Импорт и экспорт данных о категориях в форматах JSON и CSV.

*   **Управление операциями:**
    *   Создание новых операций с указанием типа (доход или расход), привязкой к банковскому счету и категории, суммы, даты и необязательного описания.
    *   Просмотр списка всех операций с подробной информацией о каждой операции.
    *   Удаление операций.
    *   Редактирование категории и описания операции.
    *   Импорт и экспорт данных об операциях в форматах JSON и CSV.

*   **Аналитика:**
    *   Подсчет разницы между доходами и расходами за выбранный пользователем период времени.
    *   Группировка доходов и расходов по категориям для наглядного представления финансовой структуры.
    *   Расчет средней суммы доходов и расходов.

## 2. Реализация принципов SOLID и GRASP

**Принципы SOLID:**

*   **Принцип единственной ответственности (SRP):**
    *   **`AccountManagerFacade`, `CategoryManagerFacade`, `OperationManagerFacade`, `AnalyticsFacade`**: Каждый фасад отвечает за управление определенной группой сущностей или функциональностью (счета, категории, операции, аналитика). Они инкапсулируют логику взаимодействия с пользователем и делегируют выполнение операций соответствующим сервисам и репозиториям.
    *   **`AccountRepository`, `CategoryRepository`, `OperationRepository`**: Репозитории отвечают исключительно за доступ к данным и взаимодействие с базой данных для соответствующих сущностей.
    *   **`JsonFileExporter`, `CsvFileExporter`, `JsonFileImporter`, `CsvFileImporter`**: Классы экспорта и импорта отвечают за сериализацию и десериализацию данных в определенные форматы.
    *   **`BankAccountFactory`, `CategoryFactory`, `OperationFactory`**: Фабрики отвечают за создание экземпляров доменных сущностей и инкапсулируют логику валидации при создании.
    *   **Команды (`CreateOperationCommand`, `DeleteOperationCommand`, `TimedCommand`)**: Каждая команда выполняет одно действие. `TimedCommand` декорирует другие команды, добавляя ответственность за измерение времени выполнения.

*   **Принцип открытости/закрытости (OCP):**
    *   **Импорт/Экспорт**: Добавление поддержки новых форматов импорта/экспорта достигается путем создания новых классов-импортеров и экспортеров, унаследованных от `FileImporterBase` и `FileExporterBase`, без изменения существующего кода `ImportExportFacade`.
    *   **Аналитика**: Добавление новых видов аналитики реализуется путем создания новых классов-посетителей, реализующих интерфейс `IVisitor`, без изменения классов сущностей (`BankAccount`, `Category`, `Operation`) или репозиториев.
    *   **Команды и Декоратор**: Можно добавлять новые команды, реализуя интерфейс `ICommand`, и новые декораторы для команд, без изменения существующей структуры команд.

*   **Принцип подстановки Барбары Лисков (LSP):**
    *   Принцип соблюдается в иерархии классов экспорта/импорта (`FileExporterBase`, `JsonFileExporter`, `CsvFileExporter` и `FileImporterBase`, `JsonFileImporter`, `CsvFileImporter`). Подклассы корректно замещают базовые классы, обеспечивая ожидаемое поведение при использовании через базовый тип.
    *   Интерфейс `ICommand` и его реализации, а также декоратор `TimedCommand` также соответствуют LSP.

*   **Принцип разделения интерфейсов (ISP):**
    *   Репозитории (`IAccountRepository`, `ICategoryRepository`, `IOperationRepository`) предоставляют отдельные интерфейсы для каждого типа сущностей, содержащие только необходимые методы для управления этими сущностями.
    *   Интерфейсы `IVisitor` и `IVisitable` четко определяют роли в паттерне "Посетитель".
    *   Интерфейс `ICommand` определяет минимальный контракт для выполнения команд.

*   **Принцип инверсии зависимостей (DIP):**
    *   Приложение зависит от абстракций, а не от конкретных реализаций. Фасады зависят от интерфейсов репозиториев (`IAccountRepository`, `ICategoryRepository`, `IOperationRepository`), а не от конкретных классов `AccountRepository`, `CategoryRepository`, `OperationRepository`.
    *   Использование фабрик (`BankAccountFactory`, `CategoryFactory`, `OperationFactory`) для создания сущностей также способствует инверсии зависимостей, поскольку код, использующий сущности, не зависит от конкретной логики их создания.
    *   Внедрение зависимостей (DI) через контейнер Microsoft.Extensions.DependencyInjection явно демонстрирует DIP, позволяя конфигурировать и заменять реализации зависимостей (например, репозиториев) без изменения кода, использующего эти зависимости.

**Принципы GRASP:**

*   **Высокое зацепление (High Cohesion):**
    *   Классы фасадов (`AccountManagerFacade`, `CategoryManagerFacade`, `OperationManagerFacade`, `AnalyticsFacade`) сгруппированы вокруг связанных задач управления сущностями и аналитики. Каждый фасад отвечает за определенный аспект пользовательского интерфейса и бизнес-логики.
    *   Репозитории (`AccountRepository`, `CategoryRepository`, `OperationRepository`) сфокусированы на операциях доступа к данным для каждой сущности.
    *   Фабрики (`BankAccountFactory`, `CategoryFactory`, `OperationFactory`) отвечают за создание экземпляров сущностей и инкапсулируют логику их инициализации и валидации.
    *   Классы экспорта/импорта (`JsonFileExporter`, `CsvFileExporter`, `JsonFileImporter`, `CsvFileImporter`) отвечают за обработку данных в конкретных форматах.
    *   Посетители (`IncomeExpenseDifferenceVisitor`, `CategoryGroupingVisitor`, `AverageOperationVisitor`) инкапсулируют логику различных видов аналитических отчетов.

*   **Низкое связывание (Low Coupling):**
    *   Фасады взаимодействуют с репозиториями через интерфейсы, что снижает зависимость от конкретных реализаций репозиториев.
    *   Использование фабрик для создания сущностей уменьшает связывание между кодом, использующим сущности, и процессом их создания.
    *   Паттерн "Команда" уменьшает связывание между пользовательским интерфейсом (фасадами) и логикой выполнения операций.
    *   Паттерн "Декоратор" позволяет добавлять функциональность (например, измерение времени) к командам без изменения самих команд, уменьшая связывание между основной логикой и дополнительными функциями.
    *   Паттерн "Прокси" (`AccountRepositoryProxy`, `CategoryRepositoryProxy`, `OperationRepositoryProxy`) инкапсулирует логику кэширования, изолируя ее от основной логики репозиториев и фасадов.

## 3. Реализованные паттерны GoF

*   **Фасад (Facade):**
    *   **Важность:** Упрощает взаимодействие пользователя с подсистемой учета финансов, предоставляя высокоуровневые интерфейсы для управления счетами, категориями, операциями и аналитикой. Скрывает сложность внутренней структуры и взаимодействия между компонентами. Повышает удобство использования и снижает связность между пользовательским интерфейсом и бизнес-логикой.
    *   **Реализация:**
        *   **`AccountManagerFacade`**: Инкапсулирует логику управления банковскими счетами (добавление, просмотр, удаление, редактирование, импорт, экспорт, пересчет).
        *   **`CategoryManagerFacade`**: Инкапсулирует логику управления категориями (добавление, просмотр, удаление, редактирование, импорт, экспорт).
        *   **`OperationManagerFacade`**: Инкапсулирует логику управления операциями (добавление, просмотр, удаление, редактирование, импорт, экспорт).
        *   **`AnalyticsFacade`**: Инкапсулирует логику выполнения различных аналитических отчетов (разница доходов/расходов, группировка по категориям, средние значения).
        *   **`ImportExportFacade<T>`**: Инкапсулирует логику импорта и экспорта данных в различные форматы (JSON, CSV), скрывая детали работы с конкретными форматами и классами-импортерами/экспортерами.

*   **Команда (Command) + Декоратор (Decorator):**
    *   **Важность:** Паттерн "Команда" позволяет представить операции (например, создание и удаление операций) как объекты, что обеспечивает гибкость и возможность добавления дополнительной логики, такой как логирование, отмена операций, или, как в данном случае, измерение времени выполнения. Паттерн "Декоратор" позволяет динамически добавлять новую функциональность к командам без изменения их структуры.
    *   **Реализация:**
        *   **Команды:**
            *   **`CreateOperationCommand`**: Реализует создание новой операции.
            *   **`DeleteOperationCommand`**: Реализует удаление операции.
        *   **Декоратор:**
            *   **`TimedCommand`**: Декоратор, который оборачивает любую команду (`ICommand`) и измеряет время ее выполнения. Применяется в `OperationManagerFacade` для измерения времени выполнения операций добавления и удаления.
    *   **Обоснование важности:** Позволяет легко добавлять измерение времени выполнения к любому пользовательскому сценарию, представленному командой, путем простого оборачивания команды в декоратор `TimedCommand`. Это обеспечивает возможность сбора статистики о производительности различных операций без изменения основного кода команд.

*   **Шаблонный метод (Template Method) - реализован через Фасад и Стратегию:**
    *   **Важность:** Обеспечивает структуру для импорта и экспорта данных, определяя общий алгоритм и позволяя подклассам (классам-импортерам и экспортерам для разных форматов) реализовывать специфические шаги (сериализация и десериализация). Способствует повторному использованию кода и соблюдению принципа OCP.
    *   **Реализация:**
        *   **`FileExporterBase<T>`**: Абстрактный базовый класс для экспортеров. Определяет шаблонный метод `Export`, который включает шаги: сериализация данных (`Serialize`) и сохранение в файл (`SaveToFile`). Метод `Serialize` является абстрактным и реализуется в подклассах.
        *   **`FileImporterBase<T>`**: Абстрактный базовый класс для импортеров. Определяет шаблонный метод `Import`, включающий шаги: загрузка содержимого файла (`LoadFileContent`) и парсинг содержимого (`Parse`). Метод `Parse` является абстрактным и реализуется в подклассах.
        *   **`JsonFileExporter<T>`, `CsvFileExporter<T>`, `JsonFileImporter<T>`, `CsvFileImporter<T>`**: Конкретные реализации для форматов JSON и CSV, реализующие абстрактные методы `Serialize` и `Parse` для соответствующих форматов.
        *   **`ImportExportFacade<T>`**: Использует стратегию выбора нужного импортера/экспортера в зависимости от формата файла, делегируя им выполнение импорта/экспорта.

*   **Посетитель (Visitor):**
    *   **Важность:** Позволяет добавлять новые операции (визиты) к иерархии объектов (`BankAccount`, `Category`, `Operation`) без изменения структуры этих классов. Упрощает добавление новых аналитических отчетов, поскольку логика каждого отчета инкапсулируется в отдельном классе-посетителе.
    *   **Реализация:**
        *   **`IVisitor`**: Интерфейс посетителя, определяющий методы `Visit` для каждого типа сущностей (`BankAccount`, `Category`, `Operation`).
        *   **`IncomeExpenseDifferenceVisitor`**: Реализует подсчет разницы между доходами и расходами за период.
        *   **`CategoryGroupingVisitor`**: Реализует группировку доходов и расходов по категориям.
        *   **`AverageOperationVisitor`**: Реализует расчет средних значений доходов и расходов.
        *   **`IVisitable`**: Интерфейс, реализованный в сущностях (`BankAccount`, `Category`, `Operation`), определяющий метод `Accept(IVisitor visitor)` для приема посетителя.
        *   Метод `Accept(IVisitor visitor)` в сущностях вызывает соответствующий метод `Visit` у посетителя, передавая себя в качестве аргумента.
        *   Репозиторий операций (`OperationRepository`) имеет метод `Accept(IVisitor visitor)`, который проходит по всем операциям и вызывает метод `Accept` для каждой из них, позволяя посетителю обработать все операции.

*   **Фабрика (Factory):**
    *   **Важность:** Инкапсулирует логику создания объектов доменной модели (`BankAccount`, `Category`, `Operation`), обеспечивая централизованное место для создания объектов и применения правил валидации. Устраняет дублирование кода создания объектов и валидации, упрощает внесение изменений в процесс создания объектов и обеспечивает консистентность создаваемых объектов.
    *   **Реализация:**
        *   **`BankAccountFactory`**: Фабрика для создания объектов `BankAccount`. Реализует интерфейс `IBankAccountFactory`. Валидирует имя счета на пустоту.
        *   **`CategoryFactory`**: Фабрика для создания объектов `Category`. Реализует интерфейс `ICategoryFactory`. Валидирует имя категории на пустоту.
        *   **`OperationFactory`**: Фабрика для создания объектов `Operation`. Реализует интерфейс `IOperationFactory`. Валидирует сумму операции на неотрицательность.

*   **Прокси (Proxy):**
    *   **Важность:** Используется для реализации кэширования данных репозиториев в памяти. Прокси перехватывает запросы к репозиториям, проверяет кэш и, при наличии данных в кэше, возвращает их оттуда, минуя обращение к базе данных. Это повышает производительность приложения за счет снижения количества обращений к базе данных для часто запрашиваемых данных.
    *   **Реализация:**
        *   **`AccountRepositoryProxy`**: Прокси для `AccountRepository`. Реализует интерфейс `IAccountRepository`. Кэширует объекты `BankAccount` в словаре `_cache`. При инициализации загружает все счета из базы данных в кэш. При запросах на чтение (например, `GetBankAccount`, `GetAllBankAccounts`) сначала проверяет кэш. При изменении данных (создание, удаление, обновление) обновляет и кэш, и базу данных.
        *   **`CategoryRepositoryProxy`**: Прокси для `CategoryRepository`. Реализует интерфейс `ICategoryRepository`. Аналогично `AccountRepositoryProxy`, кэширует объекты `Category`.
        *   **`OperationRepositoryProxy`**: Прокси для `OperationRepository`. Реализует интерфейс `IOperationRepository`. Аналогично, кэширует объекты `Operation`.

## 4. Инструкция по запуску приложения

Для запуска консольного приложения "HSE Finance" выполните следующие шаги:

1.  **Настройка переменных окружения:**
    *   Создайте файл `.env` в корневой директории проекта.
    *   В файле `.env` укажите путь к файлу базы данных SQLite, установив переменную `DATABASE_PATH`. Например:
        ```
        DATABASE_PATH=app.db
        ```
        Файл `app.db` будет создан в корневой директории проекта при первом запуске миграций.

2.  **Генерация базы данных и применение миграций:**
    *   Откройте терминал в корневой директории проекта.
    *   Выполните команду `make generate-db`.
        Эта команда выполнит следующие действия:
        *   Прочитает переменные окружения из файла `.env`.
        *   Перейдет в директорию `HSEFinance.Lib`.
        *   Выполнит команду `dotnet ef migrations add InitialCreate` для создания миграции InitialCreate (если она еще не создана).
        *   Выполнит команду `dotnet ef database update` для применения миграций к базе данных, создавая структуру базы данных в указанном файле (`app.db` в примере выше).

3.  **Запуск консольного приложения:**
    *   В том же терминале выполните команду `make run`.
        Эта команда выполнит следующие действия:
        *   Прочитает переменные окружения из файла `.env`.
        *   Перейдет в директорию `HSEFinance.ConsoleApp`.
        *   Выполнит команду `dotnet run` для запуска консольного приложения.

После запуска приложения в терминале отобразится главное меню, позволяющее управлять счетами, категориями, операциями и аналитикой через интерактивный консольный интерфейс.

## 5. Покрытие тестами

Библиотека покрыта тестами на 66%, если исключить "Migrations" (как мне кажется, стоит исключить, так как это генерируемый `dotnet ef` код, который невозможно запустить)

## 6. Использование ИИ

При написании этой работы был использован ИИ для генерации некоторых фрагментов кода при помощи inline и многострочных подсказок JetBrains AI.

Также я использовал Google Gemini и Perplexity для поиска по документации и саммаризации.

Также этот отчет был сгенерирован при повощи Google Gemini путем отправки ему всего исходного кода.
